/*
데이터 타입
CHAR - 고정 길이 문자 데이터 타입, 입력된 크기와 무관하게 지정된 길이만큼의 저장 공간이 확보 됨, 저장공간의 크기를 명시해야 하며, 크기는 1~2000BYTE
VARCHAR2 - 가변 길이 문자 데이터 타입, 실제 입력된 데이터의 크기만큼 저장 공간을 차지 함, 최대 크기를 명시해야하고 크기는 1~4000BYTE
NUMBER - 숫자를 나타내기 위한 데이터 타입(음수,0,양수 저장), 연산이 필요한 컬럼에 NUMBER를 지정, 가변길이 데이터 타입, 소수점이 지정되지 않았는데 입력되거나, 지정된 소수점 자릿수 이상이 입력되면 반올림되어 저장
` NUMBER : 최고 38자리 까지의 숫자 지정 가능
` NUMBER(W) : W자리까지의 수치로 최대 38자리까지 가능
` NUMBER(W, D) : W는 전체 자릿수, D는 소수점 이하 자릿수를 지정하며, W의 길리는 D의 길이를 포함
DATE - 날짜와 시간을 저장하는 날짜형 데이터 타입
TIMESTAMP - DATE형의 확장된 형태로 밀리초 단위까지 표현 가능
LONG - 가변길이 문자형 데이터 타입, 최대 크기는 2GB이며, 테이블에 한개의 컬럼만 생성 가능, SELECT의 결과로 데이터가 직접 조회
CLOB - 가변길이 문자형 데이터 타입, 최대 크기는 4GB이며, 테이블에 여러개의 컬럼을 생성, SELECT의 결과로 데이터의 위치 조회
RAW, LONG RAW - 이미지나 사운드를 저장할 수 있는 데이터 타입, 이진 데이터를 저장하면 16진수 형태로 표현, VARCHAR2 데이터 타입과 유사하지만 문자 변환을 수행할 수 없음
BFILE - 대용량 이진 데이터를 파일 형태로 저장하는 데이터 타입, 최대 크기는 4GB
*/
CREATE TABLE EMP_DDL(
    EMPNO NUMBER(4),
    ENAME VARCHAR2(10),
    JOB VARCHAR2(9),
    MGR NUMBER(4),
    HIREDATE DATE,
    SAL NUMBER(7, 2),
    COMM NUMBER(7, 2),
    DEPTNO NUMBER(2)
);

SELECT * FROM EMP_DDL;

CREATE TABLE DEPT_DDL AS SELECT * FROM DEPT;
DESC DEPT_DDL;

CREATE TABLE EMP_DDL_30 AS SELECT * FROM EMP WHERE DEPTNO = 30;
SELECT * FROM EMP_DDL_30;

CREATE TABLE EMPDEPT_DDL 
    AS SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, D.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE 1 != 1;

SELECT * FROM EMPDEPT_DDL;

CREATE TABLE EMP_ALTER AS SELECT *FROM EMP;
SELECT * FROM EMP_ALTER;

ALTER TABLE EMP_ALTER
    ADD HP VARCHAR(20);
SELECT * FROM EMP_ALTER;

ALTER TABLE EMP_ALTER RENAME COLUMN HP TO TEL;
SELECT * FROM EMP_ALTER;

ALTER TABLE EMP_ALTER MODIFY EMPNO NUMBER(2); -- 변경불가
ALTER TABLE EMP_ALTER MODIFY EMPNO NUMBER(10);
DESC EMP_ALTER;

ALTER TABLE EMP_ALTER
DROP COLUMN TEL;
SELECT * FROM EMP_ALTER;

RENAME EMP_ALTER TO EMP_RENAME;
SELECT * FROM EMP_RENAME;

-- 1. 다음 열의 구조를 가지는 EMP_HW테이블을 만드러 보세요.
CREATE TABLE EMP_HW(
EMPNO NUMBER(4),
ENAME VARCHAR(10),
JOB VARCHAR(9),
MGR NUMBER(4),
HIREDATE DATE,
SAL NUMBER(7, 2),
COMM NUMBER(7, 2),
DEPTNO NUMBER(2)
);
SELECT * FROM EMP_HW;

-- 2. EMP_HW 테이블에 BIGO열을 추가해보세요. BIGO열이 자료형은 가변 문자열이고, 길이는 20
ALTER TABLE EMP_HW ADD BIGO VARCHAR(20);

-- 3. EMP_HW 테이블의 BIGO열 크기를 30으로 변경
ALTER TABLE EMP_HW MODIFY BIGO VARCHAR(30);

-- 4. EMP_HW 테이블의 BIGO 열 이름을 REMARK로 변경
ALTER TABLE EMP_HW RENAME COLUMN BIGO TO REMARK;

-- 5. EMP_HW 테이블에 EMP 테이블의 데이터를 모두 저장해보세요, 단 REMAKE열은 NULL로 삽입
INSERT INTO EMP_HW SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, NULL FROM EMP;

-- 6. EMP_HW 테이블 삭제
DROP TABLE EMP_HW;


/* 제약조건 : 테이블에 저장할 데이터 제약하는 특수한 규칙을 의미. 조건에 맞지 않는 데이터 저장 불가 */
-- 빈값을 허용하지 않는 NOT NULL : 열에 대한 데이터와 중복여부는 상관없고 NULL값을 허용하지 않음(반드시 값이 입력 되어야 함)

CREATE TABLE TABLE_NOTNULL(
    LOGIN_ID VARCHAR2(20) NOT NULL,
    LOGIN_PWD VARCHAR2(20) NOT NULL,
    TEL VARCHAR2(20)
);
INSERT INTO TABLE_NOTNULL(LOGIN_ID, LOGIN_PWD, TEL) VALUES('조씨','CHOSH', '010-4907-8820');
INSERT INTO TABLE_NOTNULL(LOGIN_ID, LOGIN_PWD, TEL) VALUES('형씨','BROTHER', NULL);
SELECT * FROM TABLE_NOTNULL;

/* 중복되지 않는 값 : UNIQUE */
-- 열에 저장할 데이터의 중복을 허용하지 않음
CREATE TABLE TABLE_UNIQUE(
    LOGIN_ID VARCHAR(20) UNIQUE,
    LOGIN_PWD VARCHAR(20) NOT NULL,
    TEL VARCHAR2(20) UNIQUE
);
INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL) VALUES('조씨', 'CHOSH', '010-4907-8820');
INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL) VALUES(NULL, '12345', NULL);
SELECT * FROM TABLE_UNIQUE;

CREATE TABLE TABLE_PK(
    LOGIN_ID VARCHAR(20) UNIQUE,
    LOGIN_PWD VARCHAR(20) NOT NULL,
    TEL VARCHAR2(20) UNIQUE
);
INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL) VALUES('조씨', 'CHOSH', '010-4907-8820');
INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL) VALUES(NULL, '12345', NULL);
SELECT * FROM TABLE_PK;

CREATE TABLE DEPT_FK(
    DEPTNO NUMBER(2) CONSTRAINT DEPTFK_PEPTNO_PK PRIMARY KEY,
    DNAME VARCHAR(14),
    LOC VARCHAR(13)
);

CREATE TABLE EMP_FK(
    EMPNO NUMBER(4) CONSTRAINT EMPFK_EMPNO_PK PRIMARY KEY,
    ENAME VARCHAR2(10),
    JOB VARCHAR2(9),
    MGR NUMBER(4),
    HIREDATE DATE,
    SAL NUMBER(7,2),
    COMM NUMBER(7,2),
    DEPTNO NUMBER(2) CONSTRAINT EMPFK_DEPTNO_FK REFERENCES DEPT_FK(DEPTNO)
);
INSERT INTO DEPT_FK VALUES(10, '아이브', 'SEOUL');
INSERT INTO EMP_FK VALUES(9999, '안유진', '아이돌', NULL, SYSDATE, 3000, NULL, 10);
SELECT * FROM EMP_FK;

/* 데이터 형태와 범위를 정하는 CHECK */
CREATE TABLE TABLE_CHECK(
    LOGIN_ID VARCHAR2(20) CONSTRAINT TBLCK_LOGINID_PK PRIMARY KEY,
    LOGIN_PWD VARCHAR2(20) CONSTRAINT TBLCK_LOGINPW_CK CHECK(LENGTH(LOGIN_PWD)>3),
    TEL VARCHAR(20)
);
INSERT INTO TABLE_CHECK VALUES('조씨', '1234', '010-4907-8820');
SELECT * FROM TABLE_CHECK;

/* 기본값을 지정하는 DEFAULT */
CREATE TABLE TABLE_DEFAULT(
    LOGIN_ID VARCHAR2(20) CONSTRAINT TBCLK2_LOGINID_PK PRIMARY KEY,
    LOGIN_PWD VARCHAR2(20) DEFAULT '1234',
    TEL VARCHAR2(20)
);
INSERT INTO TABLE_DEFAULT VALUES('ASDF', NULL, 'ASDFASDFASDF');
INSERT INTO TABLE_DEFAULT (LOGIN_ID, TEL) VALUES('QWER', 'QWERQWERQWER');
SELECT * FROM TABLE_DEFAULT;

CREATE TABLE PRODUCT(
    PRODUCT_ID NUMBER CONSTRAINT PR_PRODUCT_ID_PK PRIMARY KEY,
    PRODUCT_NAME VARCHAR2(20) NOT NULL,
    REG_DATE DATE
);
INSERT INTO PRODUCT VALUES(1, 'COMPUTER', '21/01/02');
INSERT INTO PRODUCT VALUES(2, 'SAMRTPHONE', '22/02/03');
INSERT INTO PRODUCT VALUES(3, 'TELEVISION', '22/07/01');
ALTER TABLE PRODUCT ADD WEIGHT NUMBER CHECK(WEIGHT >= 0);
ALTER TABLE PRODUCT ADD PRICE NUMBER CHECK(PRICE >= 0);
SELECT * FROM PRODUCT;
--DROP TABLE PRODUCT;

CREATE TABLE CUSTOMER(
    CUSTOM_ID NUMBER CONSTRAINT CS_CUSTOM_ID_PK PRIMARY KEY,
    USER_NAME VARCHAR(12) NOT NULL,
    PHONE VARCHAR(20),
    EMAIL VARCHAR(20),
    REG_DATE DATE DEFAULT '1900/01/01'
);
ALTER TABLE CUSTOMER ADD AGE NUMBER CHECK(AGE > 0 AND AGE < 100);
ALTER TABLE CUSTOMER ADD SEX VARCHAR2(1) CHECK(SEX = 'M' OR SEX = 'F');
ALTER TABLE CUSTOMER ADD BIRTH_DATE DATE;
SELECT * FROM CUSTOMER;

/* 데이터 사전 */
-- 오라클의 데이터베이스 테이블은 사용자 테이블과 데이터 사전으로 나뉜다.
-- 데이터 사전에는 데이터베이스 메모리, 성능, 사용자, 권한, 객체 등 오라클
-- 데이터베이스 운영에 중요한 데이터가 보관되어 있다.
-- 데이터 사전 정보에 접근하ㅇ거나 변경하는 등의 작업을 할 수 없고 오로지 정보 열람만 가능
SELECT * FROM DICT;
SELECT * FROM DICTIONARY;

-- 사용자가 소유한 객체 정보가 보관되어 있음
SELECT TABLE_NAME FROM USER_TABLES;

-- ALL_ 접두어를 가진 데이터 사전은 오라클 데이터베이스에 접속해 있는 사용자가 소유한
-- 객체 및 다른 사용자가 소유한 객체 중 사용이 허락되어 있는 객체 정보
SELECT OWNER, TABLE_NAME
FROM ALL_TABLES;

/* 인덱스 */
CREATE INDEX IDX_EMP_SAL ON EMP(SAL);
SELECT * FROM USER_IND_COLUMNS;

/* 복합 인텍스 생성하기 : 두개 이상의 컴럼으로 인덱스 생성*최대 32개) */
CREATE INDEX IDX_EMP_TUPLE ON EMP(JOB, DEPTNO);

--유니크(UNIQUE) 인덱스 생성: 유니크 인덱스를 생성하면 인덱스지정된 컬럼은
-- 해당 테이블에서 유일한 값이어야 한다. ( 꼭 필요한 경우가 아니면 사용하지 말것 )
CREATE UNIQUE INDEX IDX_RMP_UK ON EMP(EMPNO, MGR);
SELECT * FROM USER_IND_COLUMNS;

-- 인덱스 삭제 : DROP
DROP INDEX IDX_EMP_SAL;

/* VIEW : 가상 테이블을 뷰라고 부른다. 뷰는 하나 이상의 테이블을 조회하는 SELECT문을 저장한 객체 */
-- 뷰는 복잡한 쿼리를 단순화 할 수 있따.
-- 사용자에게 필요한 정보만 접근하도록 접근을 제한 할 수 있다.
CREATE VIEW VW_EMP20
    AS (SELECT EMPNO, ENAME, JOB, DEPTNO FROM EMP WHERE DEPTNO = 20);

SELECT * FROM VW_EMP20;

-- 단순 뷰 생성하기
-- 단순 뷰는 단일 테이블에 필요한 컬럼을 나열 한 것 ( GROUP BY, UNION 사용하지 않음)
-- SELECT, INSERT, UPDATE, DELETE를 자유롭게 사용 가능
CREATE VIEW V_EMP
    AS(SELECT EMPNO, ENAME, JOB, HIREDATE FROM EMP);
SELECT * FROM V_EMP;

DROP VIEW V_EMP;

/* 인라인 뷰를 사용한 TOP-N SQL문 */
-- TOP-N쿼리란 데이터베이스에서 가장 큰 N개의 값을 검색하는 쿼리를 의미
-- ROWNUM을 추가로 조회하기
SELECT ROWNUM, E.*
    FROM EMP E;
    
-- 인라인뷰(서브쿼리 이용)
SELECT ROWNUM, EMP.*
    FROM (SELECT * FROM EMP ORDER BY SAL DESC) EMP;

-- 인라인부로 TOP-N 추출하기
SELECT ROWNUM, EMP.*
    FROM(SELECT*FROM EMP ORDER BY SAL DESC) EMP
    WHERE ROWNUM <= 3;
    
/* VIEW를 통한 DML문 실행 */
CREATE VIEW EMP_COPY_VIEW
    AS SELECT EMPNO, ENAME, DEPTNO
    FROM EMP;
SELECT * FROM EMP_COPY_VIEW;

INSERT INTO EMP_COPY_VIEW VALUES(9999,'조씨',30);
UPDATE EMP_COPY_VIEW
    SET DEPTNO = 20
    WHERE EMPNO = 9999;
    
    
    
